---
title: "Computational Musicology Portfolio"
author: "Robert van Straten"
date: "Last updated: 28/02/2021"
output: 
  flexdashboard::flex_dashboard:
    storyboard: true
    theme: flatly
---

```{r libraries}
library(spotifyr)
library(tidyverse)
library(expss)
library(knitr)
library(stringr)
library(forcats)
library(plotly)
library(compmus)
library(gridExtra)
library(cowplot)
```


```{r playlist information}
originals <- get_playlist_audio_features("", "67znZtLJIfAIdEOgxnRgCL")
originals <- originals[-c(10,66,68,71),] # remove duplicates of duplicates due to some Spotify API bug
row.names(originals) <- NULL # reassign row-numbers
remixes <- get_playlist_audio_features("", "0f4kAOBTCO8aEh1nrITYQL")

remixes <- remixes %>% mutate(id = row_number(), remix_name = track.name)
originals <- originals %>% mutate(id = row_number(), remix_name = remixes$remix_name)
```

```{r combine}
tracks <-
  bind_rows(
    originals %>% mutate(category = "Original recordings"),
    remixes %>% mutate(category = "Remixes")
  )
```

### _Gonna be you, and me / It's gonna be everything_, restructured by Flume

```{r ssm info}

original <-
  get_tidy_audio_analysis("55jxzrIhEupVy1l6RDJaO5") %>% # Change URI.
  compmus_align(bars, segments) %>%                     # Change `bars`
  select(bars) %>%                                      #   in all three
  unnest(bars) %>%                                      #   of these lines.
  mutate(
    pitches =
      map(segments,
        compmus_summarise, pitches,
        method = "mean", norm = "manhattan"              # Change summary & norm.
      )
  ) %>%
  mutate(
    timbre =
      map(segments,
        compmus_summarise, timbre,
        method = "mean"              # Change summary & norm.
      )
  )

remix <-
  get_tidy_audio_analysis("3W2ZcrRsInZbjWylOi6KhZ") %>% # Change URI.
  compmus_align(bars, segments) %>%                     # Change `bars`
  select(bars) %>%                                      #   in all three
  unnest(bars) %>%                                      #   of these lines.
  mutate(
    pitches =
      map(segments,
        compmus_summarise, pitches,
        method = "rms", norm = "euclidean"              # Change summary & norm.
      )
  ) %>%
  mutate(
    timbre =
      map(segments,
        compmus_summarise, timbre,
        method = "rms", norm = "euclidean"              # Change summary & norm.
      )
  )
```


```{r ssm plots}
op <- original %>%
  compmus_self_similarity(pitches, "manhattan") %>% 
  ggplot(
    aes(
      x = xstart + xduration / 2,
      width = xduration,
      y = ystart + yduration / 2,
      height = yduration,
      fill = d
    )
  ) +
  geom_tile() +
  coord_fixed() +
  scale_x_continuous(breaks = seq(0, 266.424, by = 60)) +
  scale_y_continuous(breaks = seq(0, 266.424, by = 60)) +
  scale_fill_viridis_c(guide = "none") +
  theme_classic() +
  labs(x = "", y = "")

ot <- original %>%
  compmus_self_similarity(timbre, "euclidean") %>% 
  ggplot(
    aes(
      x = xstart + xduration / 2,
      width = xduration,
      y = ystart + yduration / 2,
      height = yduration,
      fill = d
    )
  ) +
  geom_tile() +
  coord_fixed() +
  scale_x_continuous(breaks = seq(0, 266.424, by = 60)) +
  scale_y_continuous(breaks = seq(0, 266.424, by = 60)) +
  scale_fill_viridis_c(guide = "none") +
  theme_classic() +
  labs(x = "", y = "")


rp <- remix %>%
  compmus_self_similarity(pitches, "cosine") %>% 
  ggplot(
    aes(
      x = xstart + xduration / 2,
      width = xduration,
      y = ystart + yduration / 2,
      height = yduration,
      fill = d
    )
  ) +
  geom_tile() +
  coord_fixed() +
  scale_x_continuous(breaks = seq(0, 282.581, by = 60)) +
  scale_y_continuous(breaks = seq(0, 282.812, by = 60)) +
  scale_fill_viridis_c(guide = "none") +
  theme_classic() +
  labs(x = "", y = "")

rt <- remix %>%
  compmus_self_similarity(timbre, "cosine") %>% 
  ggplot(
    aes(
      x = xstart + xduration / 2,
      width = xduration,
      y = ystart + yduration / 2,
      height = yduration,
      fill = d
    )
  ) +
  geom_tile() +
  coord_fixed() +
  scale_x_continuous(breaks = seq(0, 282.812, by = 60)) +
  scale_y_continuous(breaks = seq(0, 282.812, by = 60)) +
  scale_fill_viridis_c(guide = "none") +
  theme_classic() +
  labs(x = "", y = "")
```

```{r ssm grid}
grid.arrange (arrangeGrob(op, top=grid::textGrob("You & Me", hjust = 0.15), left="Chroma"),arrangeGrob(rp,top=grid::textGrob("Flume Remix", hjust = 0.21)),arrangeGrob(ot, left="Timbre"),rt,ncol=2, nrow=2, widths = c(2.2,2) ,heights = c(2.2,2), top=grid::textGrob("Self-similarity matrices, segmented by bars, with axes in seconds", hjust= 0.42))

```

***
Flume's remix of Disclosure's "You & Me" (featuring Eliza Doolittle) had the biggest change in energy in the corpus compared to its original recording. It's also way more popular than the original. As of writing, the remix has 392 million Spotify streams, while the original has 19 million.

In the original recording, both self-similarity matrices show horizontal and vertical lines for novelty just before the chorus, where the song strips some elements. The timbre-based matrix shows a lot of blocks, which is a coherent part of the song. The chroma (pitch classes)-based matrix most clearly shows the different parts of the song. Besides the novelty lines, the part just before the line and after the line is parallel to its repetition later in the song. The difference between the first chorus and the second verse is visible as well, because it stands out as a block.

The Flume remix is not only different in energy, there's a completely different structure as well. The verses are completely gone, and only a part of the chorus (and the part just before) is used, a newcomer is the two *drop*s the song now has. The chroma-based matrix shows a lot of parallel lines, which means there's a big similarity in a later part in the song. But mostly, this matrix shows there's similarity between the drop (the large dark blue squares) and non-drop parts. The timbre-based matrix more clearly shows the (mostly just musical) parts after the drops, and the verses before the the drop are somewhat visible, due to the actual drop parts being darker.

### Introduction - Another take: It's the remix!

The corpus I chose for my Computational Musicology portfolio is a selection of remixes of (pop) songs that I like.
I've been maintaining a Spotify playlist, that now has around 75 remixed recordings, since last year. I started maintaining this playlist for myself because there are generally a lot of remixes for artists that I follow, but I was unfamiliar with most. They're quite an underappreciated part of an artist's discography. Listening to a lot of remixes and collecting those that I like was an interesting musical journey.

It'd be interesting to find out if there's some general elements shared among the remixed recordings that I like. Comparing the remixes to the original recordings can also be interesting, for sure the tempo would probably be higher for the remixes.
The definition of a remix is sometimes confusing, but the ones on my playlist are either extended remixes by the original artists or a remix where a significant amount of production on the song has been altered from the original. Remixes where the only difference is a new guest artists are **not** included on the playlist.

The corpus is a personal playlist, artists on the playlist include Lady Gaga, Dua Lipa and Charli XCX, among others.
Since the corpus is my personal playlist, it doesn't fully cover the pop remixes genre, and there aren't that many remixes of top 10 hits included.

**Typical tracks**:

1. Katy Perry - Chained To The Rhythm (Oliver Heldens Remix)
    * This is quite a typical pop remix, as there are lots on Spotify. Producers like Oliver Heldens, R3HAB and more just love to put these out. This is the type of remix that does no harm, but also doesn't bring a lot (different) to the table.
2. Lady Gaga & Ariana Grande - Rain On Me (Purple Disco Machine Remix)
    * This is basically an extended version of the original, but the beat is a bit more house. There are more extended versions/remixes of tracks on this playlist, so it's quite typical.

**Atypical tracks**:

1. Lady Gaga - Stupid Love (BloodPopÂ® & BURNS Vitaclub Warehouse Remix)
    * This is almost an entirely different song from the original. It's a lot more techno-adjacent and the structure is completely different.
2. Kesha - Praying (Frank Walker Remix)
    * This turns an acclaimed ballad into a dancefloor banger, with a good drop and build-ups. It may sound typical, but it feels so different and flips across genres.

### A remix can change a lot of aspects of a song, an expected change is the **tempo**

```{r plot1}
tracks %>%
  ggplot(aes(x= category, y = tempo)) +
  geom_violin(fill="skyblue") +
  geom_text(                  # Add outlier labels
    aes(
      y = tempo,
      label = label
    ),
    data = 
      tibble(
        label = c("Slow Down", "Need Ur Luv -\nJapanese Wallpaper\nRemix"),
        category = c("Original recordings", "Remixes"),
        tempo = c(203.579,215.997)
      ),
    colour = "black",         # Override colour.
    size = 3,                 # Override size.
    hjust = "left",           # Align left side of label with the point.
    vjust = "middle",         # Align middle of label with the point.
    nudge_x = 0.05,          # Nudge the label slightly right.
    nudge_y = -1            # Nudge the label slightly down.
  ) +
  scale_y_continuous(breaks=seq(80,220,by=20)) +
  labs(
    title = "Distribution of tempo in original and remixed recordings",
    y = "Beats per minute",
    x = element_blank()
  ) +
  theme_minimal() + theme(plot.title = element_text(hjust = 0.5), legend.position = "none")
```

***
Tracks are remixed for a large amount of reasons, an important one being: making a song more suitable for the dancefloor. This means there is probably some change in tempo. 

In the violin plot, which shows the full tempo distribution for both categories, it can be seen that for original recordings, the tempo for most tracks lies between 100-140 bpm, with a peak around 120 bpm. The tempo distribution for their remixed counterparts is far more dense, with a peak just slightly above 120 bpm. Most house music, and thus, remixes that fall into that genre, is around 128 bpm nowadays, which can be significant factor in the overall tempo change.

Tempo alone doesn't define how club-ready a track is, two other important factors are *energy* and *danceability*.

### Spotify determines **energy** and **danceability** for every song; are "my remixes" more club-ready?


```{r plot 2}

d <- highlight_key(tracks, ~id)

plot2 <- ggplot(d, aes(x=energy,y=danceability,size=tempo,color=remix_name,label=track.name)) +
geom_point(alpha=0.7) +
# geom_rug(size = 0.1) +
facet_wrap(~category) +
scale_x_continuous(         # Fine-tune the x axis.
  limits = c(0, 1),
  breaks = c(0, 0.50, 1),   # Use grid-lines for quadrants only.
  minor_breaks = NULL       # Remove 'minor' grid-lines.
) +
scale_y_continuous(         # Fine-tune the y axis in the same way.
  limits = c(0, 1),
  breaks = c(0, 0.50, 1),
  minor_breaks = NULL
) +
labs(
  title = "Energy, danceability and tempo per category",
  y = "Danceability",
  x = "Energy",
  size = "Beats per minute"
) +
theme_minimal() + theme(legend.position = "none", plot.title = element_text(hjust = 0.5))

ggplot2 <- ggplotly(plot2, tooltip = c("groups","track.name","energy","danceability","tempo") )

ggplot2 <- ggplot2 %>% layout(dragmode='zoom')

partial_bundle(highlight( ggplot2, on = "plotly_hover", off = "plotly_doubleclick"))
```

***

This graphic shows the [Spotify API](https://developer.spotify.com/documentation/web-api/reference/#object-audiofeaturesobject)-determined energy and danceability for all tracks in the corpus. Most original recordings in the corpus were already quite high in both energy and danceability, with almost all tracks being in the upper right quadrant.

Overall, energy and danceability are somewhat higher among the remixes. Their energy is distributed within the same range as the original, but a shift to the right is apparent. Danceability of the remixes is also distributed within the same range as the original tracks, but less concentrated and there are more tracks with less than 0.5 danceability, with most of those having higher energy than their original mixes.

When hovering over a point in the graphic, the exact values and song title are shown. The track's counterpart in the other category gets highlighted as well, highlights can be made undone by double-clicking on any blank space in the graphic.

### Big changes in **energy** point towards a remix being really "different" from the original recording

```{r calculate energy differences}
absdiff <- function(x) abs(diff(c(x, 0)[1:2]))

energy_absdifference <- full_join(originals, tracks) %>%
   group_by(id) %>%
   summarise_at(c("energy"),~if(n() > 1) absdiff(.) else .)

energy_absdifference <- energy_absdifference %>%
  rename(energy_absdiff=energy)

energy_difference <- full_join(originals, tracks) %>%
   group_by(id) %>%
   summarise_at(c("energy"),~if(n() > 1) diff(.) else .)

energy_difference <- energy_difference %>%
  rename(energy_diff=energy)

duration_difference <- full_join(originals, tracks) %>%
   group_by(id) %>%
   summarise_at(c("track.duration_ms"),~if(n() > 1) diff(.)/1000 else .)

duration_difference <- duration_difference %>%
  rename(duration_diff = track.duration_ms)

tracks <- merge(tracks, energy_absdifference, by="id")
tracks <- merge(tracks, energy_difference, by="id")
tracks <- merge(tracks, duration_difference, by="id")
```

```{r plot 3 differences}
most_different <- tracks %>% top_n(20, energy_absdiff) %>% mutate(remix_name = fct_reorder(remix_name,
                               energy_absdiff,
                               last)) # get 10 biggest differences (remix and original have same difference value)
ggplot(most_different) + 
geom_path(aes(x=energy,y=remix_name), 
          arrow = arrow(length = unit(1.5, "mm"), type = "closed")) +
geom_text(aes(x = energy,
              y = remix_name,
              label = sprintf("%0.2f", round(energy, digits = 2)),
              vjust=1.5),size=3) +
geom_point(aes(x=energy,y=remix_name,size=tempo), alpha=0.3, color="deepskyblue") +
labs(
  title = "Top 10 remixes with biggest change in energy, with tempo",
  y = "",
  x = "Energy (from original to remix)",
  size = "Beats per minute"
) +
  
theme_minimal() +
theme(plot.title = element_text(hjust = 0.5)) + 
scale_y_discrete(labels = function(x) str_wrap(str_replace_all(x, "foo" , " "),
                                                 width = 25)) +
coord_cartesian(xlim = c(0, 1))
```

***

Energy is an important factor, and listening to the remixes with a lot of change in the assigned energy value confirmed that. Seems that in most cases, remix with a (big) change in energy are actually very different songs.

So, what about the remixes with the smallest change in energy?


```{r table least different, echo=FALSE}
least_different <- tracks %>% filter(category=="Remixes") %>% top_n(-10, energy_absdiff) %>% arrange(energy_absdiff)

kable(least_different[,c("track.name","energy","energy_diff", "duration_diff")], caption = "Top 10 remixes with least change in energy, with duration change", floating.environment="sidewaystable", col.names = c("Remix", "Energy", "Change in energy from original", "Change in duration (seconds)"))
```

These remixes don't feel that different from the original. Half of the songs on this list are mostly remixed that are just extended versions of the original song, namely Circus, Flames, Better When You're Gone, Don't Start Now, and Toxic. It makes sense that an extended version of a song is not drastically different from the original. Also interesting is that Mura Masa has a track in both the top 10 biggest and top 10 smallest changes in energy.

<style>

    .sbframe-commentary {
    width: 20vw;
    min-width: 350px;
}

</style>