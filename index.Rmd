---
title: "Computational Musicology Portfolio"
author: "Robert van Straten"
date: "Last updated: 15/03/2021"
output: 
  flexdashboard::flex_dashboard:
    storyboard: true
    theme: flatly
---

```{r libraries}
library(spotifyr)
library(tidyverse)
library(expss)
library(knitr)
library(stringr)
library(forcats)
library(plotly)
library(compmus)
library(gridExtra)
library(cowplot)
```


```{r playlist information}
originals <- get_playlist_audio_features("", "67znZtLJIfAIdEOgxnRgCL")
originals <- originals[-c(10,66,68,71),] # remove duplicates of duplicates due to some Spotify API quirk
row.names(originals) <- NULL # reassign row-numbers
remixes <- get_playlist_audio_features("", "0f4kAOBTCO8aEh1nrITYQL")

remixes <- remixes %>% mutate(id = row_number(), remix_name = track.name)
originals <- originals %>% mutate(id = row_number(), remix_name = remixes$remix_name)
```

```{r combine}
tracks <-
  bind_rows(
    originals %>% mutate(category = "Original recordings"),
    remixes %>% mutate(category = "Remixes")
  )
```

### The _need_ for a tempo, even when it's not _that_ accurate __NEW 15/3__

```{r needurluv}
needurluv <- get_tidy_audio_analysis("1x96SvT97nQgfdgEkUiSv9")
```

```{r tempogram, cache=TRUE}
tempo1 <- needurluv %>%
  tempogram(window_size = 8, hop_size = 1, cyclic = FALSE) %>%
  ggplot(aes(x = time, y = bpm, fill = power)) +
  geom_raster() +
  scale_fill_viridis_c(guide = "none") +
  labs(x = "Time (s)", y = "Tempo (BPM)") +
  scale_y_continuous(breaks=c(0,108,162,216,324,486),labels=c(0,108,162,216,324,486)) +
  theme_minimal()
```

```{r tempogram 2, cache = TRUE}
tempo2 <- needurluv %>%
  tempogram(window_size = 8, hop_size = 1, cyclic = TRUE) %>%
  ggplot(aes(x = time, y = bpm, fill = power)) +
  geom_raster() +
  scale_fill_viridis_c(guide = "none") +
  labs(x = "Time (s)", y = "Tempo (BPM)") +
  scale_y_continuous(breaks=c(80,100,108,120,140,160),labels=c(80,100,108,120,140,160)) +
  theme_minimal()
```

```{r print tempogram}
grid.arrange(tempo1, tempo2, ncol=1)
```

***

In 2014, British pop artist Charli XCX released her sophomore album, _SUCKER_. The song "Need Ur Luv" features on the record, and has a similar vibe to BÃ˜RNS' song "Electric Love", which came out just a month before. Australian indie pop artist Japanese Wallpaper made a remix of "Need Ur Luv", which got an official release in 2018. 

```{r}
html_tag_audio <- function(file, type = c("mpeg")) {
  type <- match.arg(type)
  htmltools::tags$audio(
    controls = NA,
    htmltools::tags$source(
      src = file,
      type = glue::glue("audio/{type}", type = type)
    )
  )
}

html_tag_audio("https://p.scdn.co/mp3-preview/e53854d85f8c28c18371ec7b83fb2629ffb40f4a?cid=eee6ebfdc46d47ca8a550d4ca3a6b107", type = "mpeg")

```

_A snippet of Charli XCX - Need Ur Luv (Japanese Wallpaper Remix)_

According to Spotify, the tempo of the remix is 216 beats per minute, which should make it quite a fast peace. As seen in the first (non-cycled) tempogram, the different sections of the track lead to different strengths of _tempo octaves_, multiples of the tempo. The parts with stronger percussion are stronger at 108 beats per minute, but it seems like the chimes threw off Spotify's algorithm to pick to tempo for the whole piece. In the second tempogram, all tempi are cycled to be between the most common range of 80-160 beats per minute, resulting in a very clear line at around 108 beats per minute. It's not unfair to assume that the decision for the overall tempo of the piece also influences other metrics, like energy and danceability, which might be "inaccurate" for some pieces, even though only Spotify really knows how those are computed.

### Distribition of danceability / energy __WIP NEW 15/3__

```{r}
tracks %>%
  ggplot(aes(x= category, y = danceability)) +
  geom_violin(fill="skyblue") +
  scale_y_continuous(breaks=seq(0,1,by=0.20)) +
  labs(
    title = 'Distribution of danceability in original and remixed recordings',
   y = "Danceability",
   x = element_blank()
  ) +
  theme_minimal() + theme(plot.title = element_text(hjust = 0.5), legend.position = "none")

tracks %>%
  ggplot(aes(x= category, y = energy)) +
  geom_boxplot(fill="skyblue") +
  scale_y_continuous(breaks=seq(0,1,by=0.20)) +
  labs(
    title = "Distribution of energy in original and remixed recordings",
   y = "Energy",
   x = element_blank()
  ) +
  theme_minimal() + theme(plot.title = element_text(hjust = 0.5), legend.position = "none")
```


***

Work in progress

### Spotify determines **energy** and **valence** for every song; is there a mood shift in "my remixes"? __Updated 15/3__


```{r plot 2}

d <- highlight_key(tracks, ~id)

plot2 <- ggplot(d, aes(x=valence,y=energy,size=tempo,color=remix_name,label=track.name)) +
geom_point(alpha=0.7, aes(text=sprintf('Track: %s<br>Valence: %s | Energy: %s<br>Tempo: %s BPM', track.name, round(valence, 2), round(energy,2), round(tempo)))) +
facet_wrap(~category) +
scale_x_continuous(         # Fine-tune the x axis.
  limits = c(0, 1),
  breaks = c(0, 0.50, 1),   # Use grid-lines for quadrants only.
  minor_breaks = NULL       # Remove 'minor' grid-lines.
) +
scale_y_continuous(         # Fine-tune the y axis in the same way.
  limits = c(0, 1),
  breaks = c(0, 0.50, 1),
  minor_breaks = NULL
) +
labs(
  title = "Energy, valence and tempo per category",
  y = "Energy",
  x = "Valence",
  size = "Tempo (BPM)"
) +
theme_minimal() + theme(legend.position = "none", plot.title = element_text(hjust = 0.5))

ggplot2 <- ggplotly(plot2, tooltip = c("groups","text"))

ggplot2 <- ggplot2 %>% layout(dragmode='zoom')

partial_bundle(highlight( ggplot2, on = "plotly_hover", off = "plotly_doubleclick"))
```

***

This graphic shows the [Spotify API](https://developer.spotify.com/documentation/web-api/reference/#object-audiofeaturesobject)-determined energy and valence for all tracks in the corpus. Most original recordings in the corpus were already quite high in both energy, with almost all tracks being in the upper half.
Looking at Russell's circumplex model of affect, almost all tracks, whether remix or original, are in the happy or anxious quadrants.


![](https://www.researchgate.net/profile/Michalis-Xenos/publication/258273035/figure/fig2/AS:297671244959745@1447981763092/Russells-Circumplex-Model-of-Affect.png)


There seems to be a slight shift to the upper-left, indicating the remixes, overall, could be bit more nervous or tense.

When hovering over a point in the graphic, the exact values and song title are shown. The track's counterpart in the other category gets highlighted as well, highlights can be made undone by double-clicking on any blank space in the graphic.

### Re-mix, re-distribution of pitch classes?

```{r}
originals_an <-
  originals %>% 
  mutate(category = "Original recordings") %>%
  add_audio_analysis()
remixes_an <-
  remixes %>%
  mutate(category = "Remixes") %>%
  add_audio_analysis()
tracks_an <-
  originals_an %>%
  bind_rows(remixes_an)
```


```{r}
tracks_an %>%
  mutate(
    pitches =
      map(
        segments,
        compmus_summarise,
        pitches,
        method = "mean", norm = "manhattan"
      )
  ) %>%
  select(category, pitches) %>%
  compmus_gather_chroma() %>%
  group_by(category, pitch_class) %>% 
#  summarise(totalEnergy = median(value)) %>%
  ggplot(aes(x = pitch_class, y = value, fill=category)) +
  geom_violin() +
  theme_minimal() +
  labs(title = "Boxplots for mean pitch class value", x = "Pitch classes", y = "", fill = "Genre") +
  theme(plot.title = element_text(hjust = 0.5))
```

***

The Spotify low-level track analysis for each track holds information for each segment (a very small part, mostly less than 1 second, depending on the track), including chroma and timbre. Every segment has a chroma vector, which shows the fraction of 'energy' for the segment in each pitch class. From all segments, a mean for each song can be calculated. As seen here, when those means are visualized with a violin plot, the distribution of pitch class energy isn't all that different between the original recordings and remixes. Both have outliers in almost every pitch class, but a clear difference or trend isn't apparent.

### _Gonna be you, and me / It's gonna be everything_, restructured by Flume

```{r ssm info}

original <-
  get_tidy_audio_analysis("55jxzrIhEupVy1l6RDJaO5") %>% # Change URI.
  compmus_align(bars, segments) %>%                     # Change `bars`
  select(bars) %>%                                      #   in all three
  unnest(bars) %>%                                      #   of these lines.
  mutate(
    pitches =
      map(segments,
        compmus_summarise, pitches,
        method = "mean", norm = "manhattan"              # Change summary & norm.
      )
  ) %>%
  mutate(
    timbre =
      map(segments,
        compmus_summarise, timbre,
        method = "mean"              # Change summary & norm.
      )
  )

remix <-
  get_tidy_audio_analysis("3W2ZcrRsInZbjWylOi6KhZ") %>% # Change URI.
  compmus_align(bars, segments) %>%                     # Change `bars`
  select(bars) %>%                                      #   in all three
  unnest(bars) %>%                                      #   of these lines.
  mutate(
    pitches =
      map(segments,
        compmus_summarise, pitches,
        method = "rms", norm = "euclidean"              # Change summary & norm.
      )
  ) %>%
  mutate(
    timbre =
      map(segments,
        compmus_summarise, timbre,
        method = "rms", norm = "euclidean"              # Change summary & norm.
      )
  )
```


```{r ssm plots}
op <- original %>%
  compmus_self_similarity(pitches, "manhattan") %>% 
  ggplot(
    aes(
      x = xstart + xduration / 2,
      width = xduration,
      y = ystart + yduration / 2,
      height = yduration,
      fill = d
    )
  ) +
  geom_tile() +
  coord_fixed() +
  scale_x_continuous(breaks = seq(0, 266.424, by = 60)) +
  scale_y_continuous(breaks = seq(0, 266.424, by = 60)) +
  scale_fill_viridis_c(guide = "none") +
  theme_minimal() +
  labs(x = "", y = "")

ot <- original %>%
  compmus_self_similarity(timbre, "euclidean") %>% 
  ggplot(
    aes(
      x = xstart + xduration / 2,
      width = xduration,
      y = ystart + yduration / 2,
      height = yduration,
      fill = d
    )
  ) +
  geom_tile() +
  coord_fixed() +
  scale_x_continuous(breaks = seq(0, 266.424, by = 60)) +
  scale_y_continuous(breaks = seq(0, 266.424, by = 60)) +
  scale_fill_viridis_c(guide = "none") +
  theme_minimal() +
  labs(x = "", y = "")


rp <- remix %>%
  compmus_self_similarity(pitches, "cosine") %>% 
  ggplot(
    aes(
      x = xstart + xduration / 2,
      width = xduration,
      y = ystart + yduration / 2,
      height = yduration,
      fill = d
    )
  ) +
  geom_tile() +
  coord_fixed() +
  scale_x_continuous(breaks = seq(0, 282.581, by = 60)) +
  scale_y_continuous(breaks = seq(0, 282.812, by = 60)) +
  scale_fill_viridis_c(guide = "none") +
  theme_minimal() +
  labs(x = "", y = "")

rt <- remix %>%
  compmus_self_similarity(timbre, "cosine") %>% 
  ggplot(
    aes(
      x = xstart + xduration / 2,
      width = xduration,
      y = ystart + yduration / 2,
      height = yduration,
      fill = d
    )
  ) +
  geom_tile() +
  coord_fixed() +
  scale_x_continuous(breaks = seq(0, 282.812, by = 60)) +
  scale_y_continuous(breaks = seq(0, 282.812, by = 60)) +
  scale_fill_viridis_c(guide = "none") +
  theme_minimal() +
  labs(x = "", y = "")
```

```{r ssm grid}
grid.arrange (arrangeGrob(op, top=grid::textGrob("You & Me", hjust = 0.15), left="Chroma"),arrangeGrob(rp,top=grid::textGrob("Flume Remix", hjust = 0.21)),arrangeGrob(ot, left="Timbre"),rt,ncol=2, nrow=2, widths = c(2.2,2) ,heights = c(2.2,2), top=grid::textGrob("Self-similarity matrices, segmented by bars, with axes in seconds", hjust= 0.42))

```

***
Flume's remix of Disclosure's "You & Me" (featuring Eliza Doolittle) had the biggest change in energy in the corpus compared to its original recording. It's also way more popular than the original. As of writing, the remix has 392 million Spotify streams, while the original has 19 million.

In the original recording, both self-similarity matrices show horizontal and vertical lines for novelty just before the chorus, where the song strips some elements. The timbre-based matrix shows a lot of blocks, which is a coherent part of the song. The chroma (pitch classes)-based matrix most clearly shows the different parts of the song. Besides the novelty lines, the part just before the line and after the line is parallel to its repetition later in the song. The difference between the first chorus and the second verse is visible as well, because it stands out as a block.

The Flume remix is not only different in energy, there's a completely different structure as well. The verses are completely gone, and only a part of the chorus (and the part just before) is used, a newcomer is the two *drop*s the song now has. The chroma-based matrix shows a lot of parallel lines, which means there's a big similarity in a later part in the song. But mostly, this matrix shows there's similarity between the drop (the large dark blue squares) and non-drop parts. The timbre-based matrix more clearly shows the (mostly just musical) parts after the drops, and the verses before the the drop are somewhat visible, due to the actual drop parts being darker.

### Introduction - Another take: It's the remix!

The corpus I chose for my Computational Musicology portfolio is a selection of remixes of (pop) songs that I like.
I've been maintaining a Spotify playlist, that now has around 75 remixed recordings, since last year. I started maintaining this playlist for myself because there are generally a lot of remixes for artists that I follow, but I was unfamiliar with most. They're quite an underappreciated part of an artist's discography. Listening to a lot of remixes and collecting those that I like was an interesting musical journey.

It'd be interesting to find out if there's some general elements shared among the remixed recordings that I like. Comparing the remixes to the original recordings can also be interesting, for sure the tempo would probably be higher for the remixes.
The definition of a remix is sometimes confusing, but the ones on my playlist are either extended remixes by the original artists or a remix where a significant amount of production on the song has been altered from the original. Remixes where the only difference is a new guest artists are **not** included on the playlist.

The corpus is a personal playlist, artists on the playlist include Lady Gaga, Dua Lipa and Charli XCX, among others.
Since the corpus is my personal playlist, it doesn't fully cover the pop remixes genre, and there aren't that many remixes of top 10 hits included.

**Typical tracks**:

1. Katy Perry - Chained To The Rhythm (Oliver Heldens Remix)
    * This is quite a typical pop remix, as there are lots on Spotify. Producers like Oliver Heldens, R3HAB and more just love to put these out. This is the type of remix that does no harm, but also doesn't bring a lot (different) to the table.
2. Lady Gaga & Ariana Grande - Rain On Me (Purple Disco Machine Remix)
    * This is basically an extended version of the original, but the beat is a bit more house. There are more extended versions/remixes of tracks on this playlist, so it's quite typical.

**Atypical tracks**:

1. Lady Gaga - Stupid Love (BloodPopÂ® & BURNS Vitaclub Warehouse Remix)
    * This is almost an entirely different song from the original. It's a lot more techno-adjacent and the structure is completely different.
2. Kesha - Praying (Frank Walker Remix)
    * This turns an acclaimed ballad into a dancefloor banger, with a good drop and build-ups. It may sound typical, but it feels so different and flips across genres.

### A remix can change a lot of aspects of a song, an expected change is the **tempo**

```{r plot1}
tracks %>%
  ggplot(aes(x= category, y = tempo)) +
  geom_violin(fill="skyblue") +
  geom_text(                  # Add outlier labels
    aes(
      y = tempo,
      label = label
    ),
    data = 
      tibble(
        label = c("Slow Down", "Need Ur Luv -\nJapanese Wallpaper\nRemix"),
        category = c("Original recordings", "Remixes"),
        tempo = c(203.579,215.997)
      ),
    colour = "black",         # Override colour.
    size = 3,                 # Override size.
    hjust = "left",           # Align left side of label with the point.
    vjust = "middle",         # Align middle of label with the point.
    nudge_x = 0.05,          # Nudge the label slightly right.
    nudge_y = -1            # Nudge the label slightly down.
  ) +
  scale_y_continuous(breaks=seq(80,220,by=20)) +
  labs(
    title = "Distribution of tempo in original and remixed recordings",
    y = "Tempo (BPM)",
    x = element_blank()
  ) +
  theme_minimal() + theme(plot.title = element_text(hjust = 0.5), legend.position = "none")
```

***
Tracks are remixed for a large amount of reasons, an important one being: making a song more suitable for the dancefloor. This means there is probably some change in tempo. 

In the violin plot, which shows the full tempo distribution for both categories, it can be seen that for original recordings, the tempo for most tracks lies between 100-140 bpm, with a peak around 120 bpm. The tempo distribution for their remixed counterparts is far more dense, with a peak just slightly above 120 bpm. Most house music, and thus, remixes that fall into that genre, is around 128 bpm nowadays, which can be significant factor in the overall tempo change.

Tempo alone doesn't define how club-ready a track is, two other important factors are *energy* and *danceability*.

### Big changes in **energy** point towards a remix being really "different" from the original recording

```{r calculate energy differences}
absdiff <- function(x) abs(diff(c(x, 0)[1:2]))

energy_absdifference <- full_join(originals, tracks) %>%
   group_by(id) %>%
   summarise_at(c("energy"),~if(n() > 1) absdiff(.) else .)

energy_absdifference <- energy_absdifference %>%
  rename(energy_absdiff=energy)

energy_difference <- full_join(originals, tracks) %>%
   group_by(id) %>%
   summarise_at(c("energy"),~if(n() > 1) diff(.) else .)

energy_difference <- energy_difference %>%
  rename(energy_diff=energy)

duration_difference <- full_join(originals, tracks) %>%
   group_by(id) %>%
   summarise_at(c("track.duration_ms"),~if(n() > 1) diff(.)/1000 else .)

duration_difference <- duration_difference %>%
  rename(duration_diff = track.duration_ms)

tracks <- merge(tracks, energy_absdifference, by="id")
tracks <- merge(tracks, energy_difference, by="id")
tracks <- merge(tracks, duration_difference, by="id")
```

```{r plot 3 differences}
most_different <- tracks %>% top_n(20, energy_absdiff) %>% mutate(remix_name = fct_reorder(remix_name,
                               energy_absdiff,
                               last)) # get 10 biggest differences (remix and original have same difference value)
ggplot(most_different) + 
geom_point(aes(x=energy,y=remix_name,size=tempo), alpha=0.3, color="deepskyblue") +
geom_path(aes(x=energy,y=remix_name), 
          arrow = arrow(length = unit(1.5, "mm"), type = "closed")) +
geom_text(aes(x = energy,
              y = remix_name,
              label = sprintf("%0.2f", round(energy, digits = 2)),
              vjust=1.5),size=3) +
labs(
  title = "Top 10 remixes with biggest change in energy",
  y = "",
  x = "Energy (From original to remix)",
  size = "Tempo (BPM)"
) +
  
theme_minimal() +
theme(plot.title = element_text(hjust = 0.5)) + 
scale_y_discrete(labels = function(x) str_wrap(str_replace_all(x, "foo" , " "),
                                                 width = 25)) +
coord_cartesian(xlim = c(0, 1))
```

***

Energy is an important factor, and listening to the remixes with a lot of change in the assigned energy value confirmed that. Seems that in most cases, remix with a (big) change in energy are actually very different songs.

So, what about the remixes with the smallest change in energy?


```{r table least different, echo=FALSE}
least_different <- tracks %>% filter(category=="Remixes") %>% top_n(-10, energy_absdiff) %>% arrange(energy_absdiff)

kable(least_different[,c("track.name","energy","energy_diff", "duration_diff")], caption = "Top 10 remixes with least change in energy, with duration change", floating.environment="sidewaystable", col.names = c("Remix", "Energy", "Change in energy from original", "Change in duration (seconds)"))
```

These remixes don't feel that different from the original. Half of the songs on this list are mostly remixed that are just extended versions of the original song, namely Circus, Flames, Better When You're Gone, Don't Start Now, and Toxic. It makes sense that an extended version of a song is not drastically different from the original. Also interesting is that Mura Masa has a track in both the top 10 biggest and top 10 smallest changes in energy.

<style>

    .sbframe-commentary {
    width: 21vw;
    min-width: 350px;
}

</style>